using Plots
using IterTools: partition

"""
Convenience function for plotting a heatmap in grayscale and the right orientation
    to view a digit
"""
function plot_digit(x; color=:grays, alpha=1, boundc=true, kwargs...)
    return heatmap(x[:, end:-1:1]';
        color=color,
        clim=boundc ? (0, 1) : (minimum(x), maximum(x)),
        axis=nothing,
        colorbar=false,
        alpha=alpha,
        kwargs...)
end

"""
In-place version of `plot_digit`
"""
function plot_digit!(x; color=:grays, alpha=1, boundc=true, kwargs...)
    return heatmap!(x[:, end:-1:1]';
        color=color,
        clim=boundc ? (0, 1) : (minimum(x), maximum(x)),
        # clim=(0, 1),
        axis=nothing,
        colorbar=false,
        alpha=alpha,
        kwargs...)
end

"""
Stack the arrays in `xs` into an `n x n` grid
"""
function stack_ims(xs; n=nothing)
    sz = size(xs)
    n = n === nothing ? trunc(Int, sqrt(size(xs)[end])) : n
    xs = if length(sz) > 3 & size(xs, 3) == 1
        xs = dropdims(xs, dims=3)
        collect(eachslice(xs, dims=3))
    elseif length(sz) == 3
        collect(eachslice(xs, dims=3))
    else
        collect(eachslice(xs, dims=4))
    end
    rows_ = map(x -> hcat(x...), partition(xs, n))
    return vcat(rows_...)
end

# ==== Plotting RNP sequences ====

"""
Have "grayscale" array x render as orange in RGB
"""
function rgb_to_orange(x)
    a = x
    b = 0.65f0 .* x
    c = 0.0f0 .* x
    cat(a, b, c, dims=3)
end


function orange_on_rgb(xs)
    orange_patch = rgb_to_orange(xs[end])
    min.(cat(xs[1:3]..., dims=3) .+ orange_patch, 1.0f0)
end

"""
Create an RGB image from a vector of patches generated by an RNP.
If there are 4 patches, the 4th is orange. If less, there'll be some purple ðŸ¥°
"""
function view_patches_rgb(patches, ind)
    im_array = orange_on_rgb(patches)
    colorview(RGB, permutedims(im_array[:, :, :, ind], [3, 1, 2]))
end

